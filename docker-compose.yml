services:
  # ============================================================================
  # OTIMIZADO PARA VM: 12 cores (2x6) e 8GB RAM
  # ============================================================================
  db:
    image: mysql:8.0
    container_name: churn-db
    restart: always
    environment:
      MYSQL_DATABASE: ${DB_NAME}
      MYSQL_ROOT_PASSWORD: ${DB_ROOT_PASSWORD}
      MYSQL_USER: ${DB_USER}
      MYSQL_PASSWORD: ${DB_PASSWORD}
    command:
      - --character-set-server=utf8mb4
      - --collation-server=utf8mb4_unicode_ci
      - --performance-schema=OFF
      - --innodb-buffer-pool-size=1G
      - --innodb-log-file-size=256M
      - --innodb-flush-log-at-trx-commit=2
      - --innodb-flush-method=O_DIRECT
      - --innodb-read-io-threads=4
      - --innodb-write-io-threads=4
      - --max-connections=100
      - --thread-cache-size=30
      - --tmp-table-size=64M
      - --max-heap-table-size=64M
    volumes:
      - mysql_data:/var/lib/mysql
    networks:
      - churn-net
    healthcheck:
      test: ["CMD", "mysqladmin" ,"ping", "-h", "localhost"]
      interval: 10s
      timeout: 5s
      retries: 5
    deploy:
      resources:
        limits:
          cpus: '2.0'        # reduzir para preservar CPU para app
          memory: 1500M      # 1.5GB para MySQL
        reservations:
          memory: 1G

  app:
    image: ${DOCKER_USERNAME}/churn-api:latest
    container_name: churn-api
    restart: on-failure
    pull_policy: always
    depends_on:
      db:
        condition: service_healthy

    env_file:
      - .env

    ports:
      - "${APP_PORT}:${APP_PORT}"

    environment:
      SPRING_DATASOURCE_URL: jdbc:mysql://db:3306/${DB_NAME}?allowPublicKeyRetrieval=true&useSSL=false&rewriteBatchedStatements=true&cachePrepStmts=true&prepStmtCacheSize=250&useServerPrepStmts=true
      SPRING_DATASOURCE_USERNAME: ${DB_USER}
      SPRING_DATASOURCE_PASSWORD: ${DB_PASSWORD}
      SPRING_JPA_HIBERNATE_DDL_AUTO: update
      SERVER_PORT: ${APP_PORT}
      APP_PUBLIC_BASE_URL: "http://localhost:${APP_PORT}"
      # JVM otimizada - heap abaixo do limite de memória do container
      JAVA_OPTS: "-Xmx3g -Xms1g -XX:+UseZGC -XX:MaxGCPauseMillis=200 -XX:+UseStringDeduplication"

    networks:
      - churn-net
    deploy:
      resources:
        limits:
          cpus: '6.0'        # alocar até metade dos logical cores (~6 cores)
          memory: 3500M      # ~3.5GB para o app (JVM + native libs ONNX)
        reservations:
          memory: 2G
    # Healthcheck: garante que o container só será considerado saudável quando o actuator estiver UP
    healthcheck:
      test: ["CMD-SHELL", "curl -f http://localhost:${APP_PORT}/actuator/health || exit 1"]
      interval: 30s
      timeout: 5s
      retries: 3
    # secrets removidos — usando variáveis de ambiente definidas em .env

  # ============================================================================
  # FRONTEND (React + Nginx)
  # ============================================================================
  frontend:
    image: ${DOCKER_USERNAME}/churn-frontend:latest
    container_name: churn-frontend
    restart: on-failure
    pull_policy: always
    depends_on:
      - app
    ports:
      - "3000:3000"
    networks:
      - churn-net
    deploy:
      resources:
        limits:
          cpus: '0.5'
          memory: 256M
    healthcheck:
      test: ["CMD", "wget", "--no-verbose", "--tries=1", "--spider", "http://localhost:3000/health"]
      interval: 30s
      timeout: 3s
      retries: 3

  # ============================================================================
  # AUTOMACAO DE DEPLOY (INFRA)
  # ============================================================================
  watchtower:
    image: containrrr/watchtower
    container_name: watchtower
    restart: always
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock
    command: --interval 30 --cleanup
    environment:
      - DOCKER_API_VERSION=1.45
    networks:
      - churn-net

  # ============================================================================
  # STACK DE OBSERVABILIDADE
  # ============================================================================
  prometheus:
    image: prom/prometheus:latest
    container_name: monitoring-prometheus
    volumes:
      - ./monitoring/prometheus/prometheus.yml:/etc/prometheus/prometheus.yml
    ports:
      - "127.0.0.1:${PROMETHEUS_PORT}:${PROMETHEUS_PORT}" # bind to localhost only for security
    networks:
      - churn-net
    deploy:
      resources:
        limits:
          cpus: '0.5'
          memory: 256M

  grafana:
    image: grafana/grafana:latest
    container_name: monitoring-grafana
    ports:
      - "127.0.0.1:${GRAFANA_PORT}:${GRAFANA_PORT}" # bind to localhost only; use reverse proxy/SSH tunnel for external access
    environment:
      - GF_SECURITY_ADMIN_PASSWORD=${GF_ADMIN_PASSWORD}
      - GF_INSTALL_PLUGINS=alexanderzobnin-zabbix-app
      - ZABBIX_USER=${ZABBIX_USER}
      - ZABBIX_PASSWORD=${ZABBIX_PASSWORD}
    volumes:
      - grafana_data:/var/lib/grafana
      - ./monitoring/grafana/provisioning:/etc/grafana/provisioning
    depends_on:
      - prometheus
      - zabbix-web
    networks:
      - churn-net
    deploy:
      resources:
        limits:
          cpus: '0.5'
          memory: 256M

  # ZABBIX
  zabbix-server:
    image: zabbix/zabbix-server-mysql:latest
    container_name: zabbix-server
    ports:
      - "${ZABBIX_SERVER_PORT}:${ZABBIX_SERVER_PORT}"
    environment:
      - DB_SERVER_HOST=zabbix-db
      - MYSQL_USER=zabbix
      - MYSQL_PASSWORD=${MYSQL_ZABBIX_PASSWORD}
      - MYSQL_DATABASE=zabbix
    depends_on:
      - zabbix-db
    networks:
      - churn-net

  zabbix-web:
    image: zabbix/zabbix-web-nginx-mysql:latest
    container_name: zabbix-web
    restart: always
    ports:
      - "127.0.0.1:${ZABBIX_WEB_PORT}:8080" # bind to localhost only
    environment:
      - DB_SERVER_HOST=zabbix-db
      - MYSQL_USER=zabbix
      - MYSQL_PASSWORD=${MYSQL_ZABBIX_PASSWORD}
      - MYSQL_DATABASE=zabbix
      - ZBX_SERVER_HOST=zabbix-server
      - PHP_TZ=America/Sao_Paulo
    depends_on:
      - zabbix-server
    networks:
      - churn-net

  zabbix-db:
    image: mysql:8.0
    container_name: zabbix-db
    command:
      - --character-set-server=utf8mb4
      - --collation-server=utf8mb4_bin
      - --default-authentication-plugin=mysql_native_password
      - --log_bin_trust_function_creators=1
    environment:
      - MYSQL_USER=zabbix
      - MYSQL_PASSWORD=${MYSQL_ZABBIX_PASSWORD}
      - MYSQL_DATABASE=zabbix
      - MYSQL_ROOT_PASSWORD=${MYSQL_ROOT_ZABBIX_PASSWORD}
    volumes:
      - zabbix_db_data:/var/lib/mysql
    networks:
      - churn-net
    deploy:
      resources:
        limits:
          memory: 1024M

  tunnel:
    image: cloudflare/cloudflared:latest
    container_name: cloudflare-tunnel
    restart: unless-stopped
    command: tunnel --url http://churn-frontend:3000 --metrics 0.0.0.0:2000
    networks:
      - churn-net
    depends_on:
      - frontend

networks:
  churn-net:
    driver: bridge

volumes:
  mysql_data:
  zabbix_db_data:
  grafana_data:

